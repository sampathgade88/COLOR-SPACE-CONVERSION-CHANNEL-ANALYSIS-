# -*- coding: utf-8 -*-
"""ACV_LAB1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LF-dGWde0HeuvhuHnv9v2pvKg2xvHJ7a
"""

from google.colab import files
import cv2
import matplotlib.pyplot as plt
import numpy as np
import os

# ---------------------------------------------
# 1. Ask user to upload an image
# ---------------------------------------------
uploaded = files.upload()

# Get the filename
filename = list(uploaded.keys())[0]
print("Uploaded File:", filename)

# ---------------------------------------------
# 2. Read the uploaded image
# ---------------------------------------------
img_bgr = cv2.imread(filename)

if img_bgr is None:
    raise ValueError("Error: Image could not be loaded")

h, w = img_bgr.shape[:2]
channels = img_bgr.shape[2]
size_kb = os.path.getsize(filename) / 1024

print("\nImage Information:")
print(f"  Dimensions : {w} x {h}")
print(f"  Channels   : {channels}")
print(f"  File size  : {size_kb:.2f} KB")
print(f"  Data type  : {img_bgr.dtype}")

# Convert BGR → RGB (for display)
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

# Show original image
plt.figure(figsize=(5,5))
plt.imshow(img_rgb)
plt.title("Original Image")
plt.axis("off")
plt.show()

# ---------------------------------------------
# 3. Convert RGB → HSV and YCbCr
# ---------------------------------------------
img_hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
img_ycrcb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2YCrCb)

# Split channels
R, G, B = cv2.split(img_rgb)
H, S, V = cv2.split(img_hsv)
Y, Cr, Cb = cv2.split(img_ycrcb)

# ---------------------------------------------
# Helper function to show each channel
# ---------------------------------------------
def show_channels(title, channels, names):
    plt.figure(figsize=(15, 4))
    for i, (ch, name) in enumerate(zip(channels, names), 1):
        plt.subplot(1, len(channels), i)
        plt.imshow(ch, cmap="gray")
        plt.title(f"{title} - {name}")
        plt.axis("off")
    plt.show()

# ---------------------------------------------
# 4. Display all channels
# ---------------------------------------------
show_channels("RGB", [R, G, B], ["R", "G", "B"])
show_channels("HSV", [H, S, V], ["Hue (H)", "Saturation (S)", "Value (V)"])
show_channels("YCbCr", [Y, Cb, Cr], ["Y (Luma)", "Cb (Blue-Chroma)", "Cr (Red-Chroma)"])

# Experiment-1 (Colab-ready)
# RGB -> HSV -> YCbCr analysis (auto-detect uploaded image in /content)
import os
import cv2
import numpy as np
from matplotlib import pyplot as plt

# ---------------------------
# Helper: find image in /content
# ---------------------------
def find_image_in_content():
    content_dir = "/content"
    exts = (".png", ".jpg", ".jpeg", ".bmp", ".tiff", ".tif")
    candidates = []
    for fname in os.listdir(content_dir):
        if fname.lower().endswith(exts):
            candidates.append(os.path.join(content_dir, fname))
    # sort so deterministic if multiple
    candidates.sort()
    return candidates[0] if candidates else None

# ---------------------------
# If not found, ask user to upload (Colab)
# ---------------------------
img_path = find_image_in_content()
if img_path is None:
    try:
        from google.colab import files
        print("No image found in /content. Please upload an image (PNG/JPG/BMP).")
        uploaded = files.upload()  # opens upload dialog in Colab
        # take the first uploaded filename
        if uploaded:
            img_path = "/content/" + next(iter(uploaded.keys()))
    except Exception as e:
        raise RuntimeError("No image found and automatic upload is not available in this environment.") from e

if img_path is None:
    raise FileNotFoundError("No image provided. Upload an image to /content or re-run the cell and upload.")

print(f"Using image: {img_path}")

# ---------------------------
# Load image (OpenCV reads BGR)
# ---------------------------
img_bgr = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)
if img_bgr is None:
    raise ValueError(f"Failed to load image at {img_path}")

# If image has alpha channel, remove it for color-space conversions
if img_bgr.ndim == 3 and img_bgr.shape[2] == 4:
    img_bgr = cv2.cvtColor(img_bgr, cv2.COLOR_BGRA2BGR)

# Convert to RGB for human-correct display and consistent conversions
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

# ---------------------------
# Print properties
# ---------------------------
height, width = img_rgb.shape[:2]
channels = img_rgb.shape[2] if img_rgb.ndim == 3 else 1
dtype = img_rgb.dtype
bits_per_channel = img_rgb.itemsize * 8

try:
    file_size = os.path.getsize(img_path)
except OSError:
    file_size = None

print("\nImage Properties:")
print(f" • Path          : {img_path}")
print(f" • Width x Height: {width} x {height}")
print(f" • Channels      : {channels}")
print(f" • Dtype         : {dtype}")
print(f" • Bits/channel  : {bits_per_channel}")
if file_size is not None:
    print(f" • File size     : {file_size} bytes")

# ---------------------------
# Convert color spaces
# ---------------------------
hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)       # H:0-179 in OpenCV
ycrcb = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2YCrCb)   # OpenCV returns Y, Cr, Cb order

# Split channels
R, G, B = cv2.split(img_rgb)
H, S, V = cv2.split(hsv)
Y, Cr, Cb = cv2.split(ycrcb)   # note: order is Y, Cr, Cb

# ---------------------------
# Display helper
# ---------------------------
def show(img, title="", cmap=None, figsize=(5,5)):
    plt.figure(figsize=figsize)
    if img.ndim == 2:
        plt.imshow(img, cmap=cmap)
    else:
        plt.imshow(img)
    plt.title(title)
    plt.axis("off")
    plt.show()

# ---------------------------
# Display original and channels
# ---------------------------
show(img_rgb, "Original (RGB)")

# RGB channels (as grayscale images)
show(R, "Red channel (R)", cmap="gray")
show(G, "Green channel (G)", cmap="gray")
show(B, "Blue channel (B)", cmap="gray")

# HSV channels
# Hue in OpenCV is 0-179; display as-is (visual) - you can scale if preferred
show(H, "Hue (H) - values 0..179", cmap="gray")
show(S, "Saturation (S)", cmap="gray")
show(V, "Value / Brightness (V)", cmap="gray")

# YCrCb channels
# Important: cv2.COLOR_RGB2YCrCb gives channels in order Y, Cr, Cb
show(Y, "Luminance (Y)", cmap="gray")
show(Cb, "Chrominance Blue (Cb) — note OpenCV split gave Cr,Cb; we assigned Cb accordingly", cmap="gray")
show(Cr, "Chrominance Red (Cr)", cmap="gray")

# ---------------------------
# Simple visual comparisons
# ---------------------------
# Reconstruct images using single channels (for intuition)
zeros = np.zeros_like(R)
only_R = cv2.merge([R, zeros, zeros])
only_G = cv2.merge([zeros, G, zeros])
only_B = cv2.merge([zeros, zeros, B])

show(only_R, "Only Red (visualized in RGB)")
show(only_G, "Only Green (visualized in RGB)")
show(only_B, "Only Blue (visualized in RGB)")

# ---------------------------
# Interpretation (printed)
# ---------------------------
print("\n--- Channel Interpretation Summary ---")
print(" • H (Hue)    : dominant color tone (useful for color-based segmentation).")
print(" • S (Sat)    : color purity - low S ≈ desaturated (grayish).")
print(" • V (Value)  : brightness / intensity (similar to luminance but not identical).")
print(" • Y (Luma)   : captures brightness (used in compression, detection).")
print(" • Cb / Cr    : color-difference (chrominance) channels; Cb ~ blue-difference, Cr ~ red-difference.")
print("\nNotes:")
print(" - HSV decouples color from intensity (helpful for tracking under illumination changes).")
print(" - YCrCb separates luminance and chrominance (widely used in video & JPEG compression).")